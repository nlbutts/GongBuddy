// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gb_messages.proto

#include "gb_messages.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_gb_5fmessages_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_IMUSample_gb_5fmessages_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_gb_5fmessages_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Sensor_gb_5fmessages_2eproto;
class SensorDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Sensor> _instance;
} _Sensor_default_instance_;
class IMUSampleDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<IMUSample> _instance;
} _IMUSample_default_instance_;
class LoraMsgDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<LoraMsg> _instance;
} _LoraMsg_default_instance_;
class ReprogrammingDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<Reprogramming> _instance;
} _Reprogramming_default_instance_;
static void InitDefaultsscc_info_IMUSample_gb_5fmessages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_IMUSample_default_instance_;
    new (ptr) ::IMUSample();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::IMUSample::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_IMUSample_gb_5fmessages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_IMUSample_gb_5fmessages_2eproto}, {
      &scc_info_Sensor_gb_5fmessages_2eproto.base,}};

static void InitDefaultsscc_info_LoraMsg_gb_5fmessages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_LoraMsg_default_instance_;
    new (ptr) ::LoraMsg();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::LoraMsg::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_LoraMsg_gb_5fmessages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, 0, InitDefaultsscc_info_LoraMsg_gb_5fmessages_2eproto}, {
      &scc_info_IMUSample_gb_5fmessages_2eproto.base,}};

static void InitDefaultsscc_info_Reprogramming_gb_5fmessages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Reprogramming_default_instance_;
    new (ptr) ::Reprogramming();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Reprogramming::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Reprogramming_gb_5fmessages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Reprogramming_gb_5fmessages_2eproto}, {}};

static void InitDefaultsscc_info_Sensor_gb_5fmessages_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_Sensor_default_instance_;
    new (ptr) ::Sensor();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::Sensor::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_Sensor_gb_5fmessages_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_Sensor_gb_5fmessages_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_gb_5fmessages_2eproto[4];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_gb_5fmessages_2eproto[1];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_gb_5fmessages_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_gb_5fmessages_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::Sensor, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Sensor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Sensor, x_),
  PROTOBUF_FIELD_OFFSET(::Sensor, y_),
  PROTOBUF_FIELD_OFFSET(::Sensor, z_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::IMUSample, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::IMUSample, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::IMUSample, accel_),
  PROTOBUF_FIELD_OFFSET(::IMUSample, gyro_),
  PROTOBUF_FIELD_OFFSET(::IMUSample, pressure_),
  PROTOBUF_FIELD_OFFSET(::IMUSample, temperature_),
  0,
  1,
  2,
  3,
  PROTOBUF_FIELD_OFFSET(::LoraMsg, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::LoraMsg, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::LoraMsg, buildnum_),
  PROTOBUF_FIELD_OFFSET(::LoraMsg, status_),
  PROTOBUF_FIELD_OFFSET(::LoraMsg, imu_),
  PROTOBUF_FIELD_OFFSET(::LoraMsg, batt_voltage_),
  PROTOBUF_FIELD_OFFSET(::LoraMsg, threshold_),
  PROTOBUF_FIELD_OFFSET(::LoraMsg, configuration_),
  0,
  1,
  ~0u,
  2,
  3,
  4,
  PROTOBUF_FIELD_OFFSET(::Reprogramming, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::Reprogramming, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::Reprogramming, address_),
  PROTOBUF_FIELD_OFFSET(::Reprogramming, data_),
  PROTOBUF_FIELD_OFFSET(::Reprogramming, flags_),
  1,
  0,
  2,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::Sensor)},
  { 11, 20, sizeof(::IMUSample)},
  { 24, 35, sizeof(::LoraMsg)},
  { 41, 49, sizeof(::Reprogramming)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Sensor_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_IMUSample_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_LoraMsg_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_Reprogramming_default_instance_),
};

const char descriptor_table_protodef_gb_5fmessages_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\021gb_messages.proto\")\n\006Sensor\022\t\n\001x\030\001 \002(\021"
  "\022\t\n\001y\030\002 \002(\021\022\t\n\001z\030\003 \002(\021\"a\n\tIMUSample\022\026\n\005a"
  "ccel\030\001 \002(\0132\007.Sensor\022\025\n\004gyro\030\002 \002(\0132\007.Sens"
  "or\022\020\n\010pressure\030\003 \002(\021\022\023\n\013temperature\030\004 \002("
  "\021\"\204\001\n\007LoraMsg\022\020\n\010buildnum\030\001 \002(\r\022\016\n\006statu"
  "s\030\002 \001(\r\022\027\n\003imu\030\003 \003(\0132\n.IMUSample\022\024\n\014batt"
  "_voltage\030\004 \001(\r\022\021\n\tthreshold\030\005 \001(\r\022\025\n\rcon"
  "figuration\030\006 \001(\r\"\205\001\n\rReprogramming\022\017\n\007ad"
  "dress\030\001 \002(\r\022\014\n\004data\030\002 \002(\014\022-\n\005flags\030\003 \002(\016"
  "2\024.Reprogramming.Flags:\010CONTINUE\"&\n\005Flag"
  "s\022\017\n\013LAST_PACKET\020\000\022\014\n\010CONTINUE\020\001"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_gb_5fmessages_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_gb_5fmessages_2eproto_sccs[4] = {
  &scc_info_IMUSample_gb_5fmessages_2eproto.base,
  &scc_info_LoraMsg_gb_5fmessages_2eproto.base,
  &scc_info_Reprogramming_gb_5fmessages_2eproto.base,
  &scc_info_Sensor_gb_5fmessages_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_gb_5fmessages_2eproto_once;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_gb_5fmessages_2eproto = {
  false, false, descriptor_table_protodef_gb_5fmessages_2eproto, "gb_messages.proto", 432,
  &descriptor_table_gb_5fmessages_2eproto_once, descriptor_table_gb_5fmessages_2eproto_sccs, descriptor_table_gb_5fmessages_2eproto_deps, 4, 0,
  schemas, file_default_instances, TableStruct_gb_5fmessages_2eproto::offsets,
  file_level_metadata_gb_5fmessages_2eproto, 4, file_level_enum_descriptors_gb_5fmessages_2eproto, file_level_service_descriptors_gb_5fmessages_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_gb_5fmessages_2eproto = (static_cast<void>(::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_gb_5fmessages_2eproto)), true);
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* Reprogramming_Flags_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_gb_5fmessages_2eproto);
  return file_level_enum_descriptors_gb_5fmessages_2eproto[0];
}
bool Reprogramming_Flags_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr Reprogramming_Flags Reprogramming::LAST_PACKET;
constexpr Reprogramming_Flags Reprogramming::CONTINUE;
constexpr Reprogramming_Flags Reprogramming::Flags_MIN;
constexpr Reprogramming_Flags Reprogramming::Flags_MAX;
constexpr int Reprogramming::Flags_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void Sensor::InitAsDefaultInstance() {
}
class Sensor::_Internal {
 public:
  using HasBits = decltype(std::declval<Sensor>()._has_bits_);
  static void set_has_x(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_y(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_z(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

Sensor::Sensor(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:Sensor)
}
Sensor::Sensor(const Sensor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&x_, &from.x_,
    static_cast<size_t>(reinterpret_cast<char*>(&z_) -
    reinterpret_cast<char*>(&x_)) + sizeof(z_));
  // @@protoc_insertion_point(copy_constructor:Sensor)
}

void Sensor::SharedCtor() {
  ::memset(&x_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&z_) -
      reinterpret_cast<char*>(&x_)) + sizeof(z_));
}

Sensor::~Sensor() {
  // @@protoc_insertion_point(destructor:Sensor)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Sensor::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void Sensor::ArenaDtor(void* object) {
  Sensor* _this = reinterpret_cast< Sensor* >(object);
  (void)_this;
}
void Sensor::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Sensor::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Sensor& Sensor::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Sensor_gb_5fmessages_2eproto.base);
  return *internal_default_instance();
}


void Sensor::Clear() {
// @@protoc_insertion_point(message_clear_start:Sensor)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&x_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&z_) -
        reinterpret_cast<char*>(&x_)) + sizeof(z_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Sensor::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required sint32 x = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_x(&has_bits);
          x_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required sint32 y = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_y(&has_bits);
          y_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required sint32 z = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_z(&has_bits);
          z_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Sensor::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Sensor)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required sint32 x = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(1, this->_internal_x(), target);
  }

  // required sint32 y = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(2, this->_internal_y(), target);
  }

  // required sint32 z = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(3, this->_internal_z(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Sensor)
  return target;
}

size_t Sensor::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Sensor)
  size_t total_size = 0;

  if (_internal_has_x()) {
    // required sint32 x = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
        this->_internal_x());
  }

  if (_internal_has_y()) {
    // required sint32 y = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
        this->_internal_y());
  }

  if (_internal_has_z()) {
    // required sint32 z = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
        this->_internal_z());
  }

  return total_size;
}
size_t Sensor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Sensor)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required sint32 x = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
        this->_internal_x());

    // required sint32 y = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
        this->_internal_y());

    // required sint32 z = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
        this->_internal_z());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Sensor::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Sensor)
  GOOGLE_DCHECK_NE(&from, this);
  const Sensor* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Sensor>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Sensor)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Sensor)
    MergeFrom(*source);
  }
}

void Sensor::MergeFrom(const Sensor& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Sensor)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      x_ = from.x_;
    }
    if (cached_has_bits & 0x00000002u) {
      y_ = from.y_;
    }
    if (cached_has_bits & 0x00000004u) {
      z_ = from.z_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Sensor::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Sensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Sensor::CopyFrom(const Sensor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Sensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Sensor::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Sensor::InternalSwap(Sensor* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(Sensor, z_)
      + sizeof(Sensor::z_)
      - PROTOBUF_FIELD_OFFSET(Sensor, x_)>(
          reinterpret_cast<char*>(&x_),
          reinterpret_cast<char*>(&other->x_));
}

::PROTOBUF_NAMESPACE_ID::Metadata Sensor::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void IMUSample::InitAsDefaultInstance() {
  ::_IMUSample_default_instance_._instance.get_mutable()->accel_ = const_cast< ::Sensor*>(
      ::Sensor::internal_default_instance());
  ::_IMUSample_default_instance_._instance.get_mutable()->gyro_ = const_cast< ::Sensor*>(
      ::Sensor::internal_default_instance());
}
class IMUSample::_Internal {
 public:
  using HasBits = decltype(std::declval<IMUSample>()._has_bits_);
  static const ::Sensor& accel(const IMUSample* msg);
  static void set_has_accel(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::Sensor& gyro(const IMUSample* msg);
  static void set_has_gyro(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_pressure(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_temperature(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x0000000f) ^ 0x0000000f) != 0;
  }
};

const ::Sensor&
IMUSample::_Internal::accel(const IMUSample* msg) {
  return *msg->accel_;
}
const ::Sensor&
IMUSample::_Internal::gyro(const IMUSample* msg) {
  return *msg->gyro_;
}
IMUSample::IMUSample(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:IMUSample)
}
IMUSample::IMUSample(const IMUSample& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  if (from._internal_has_accel()) {
    accel_ = new ::Sensor(*from.accel_);
  } else {
    accel_ = nullptr;
  }
  if (from._internal_has_gyro()) {
    gyro_ = new ::Sensor(*from.gyro_);
  } else {
    gyro_ = nullptr;
  }
  ::memcpy(&pressure_, &from.pressure_,
    static_cast<size_t>(reinterpret_cast<char*>(&temperature_) -
    reinterpret_cast<char*>(&pressure_)) + sizeof(temperature_));
  // @@protoc_insertion_point(copy_constructor:IMUSample)
}

void IMUSample::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_IMUSample_gb_5fmessages_2eproto.base);
  ::memset(&accel_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&temperature_) -
      reinterpret_cast<char*>(&accel_)) + sizeof(temperature_));
}

IMUSample::~IMUSample() {
  // @@protoc_insertion_point(destructor:IMUSample)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void IMUSample::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  if (this != internal_default_instance()) delete accel_;
  if (this != internal_default_instance()) delete gyro_;
}

void IMUSample::ArenaDtor(void* object) {
  IMUSample* _this = reinterpret_cast< IMUSample* >(object);
  (void)_this;
}
void IMUSample::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void IMUSample::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const IMUSample& IMUSample::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_IMUSample_gb_5fmessages_2eproto.base);
  return *internal_default_instance();
}


void IMUSample::Clear() {
// @@protoc_insertion_point(message_clear_start:IMUSample)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(accel_ != nullptr);
      accel_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(gyro_ != nullptr);
      gyro_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&pressure_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&temperature_) -
        reinterpret_cast<char*>(&pressure_)) + sizeof(temperature_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* IMUSample::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .Sensor accel = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_accel(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .Sensor gyro = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_gyro(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required sint32 pressure = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_pressure(&has_bits);
          pressure_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required sint32 temperature = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_temperature(&has_bits);
          temperature_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarintZigZag32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* IMUSample::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:IMUSample)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .Sensor accel = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::accel(this), target, stream);
  }

  // required .Sensor gyro = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::gyro(this), target, stream);
  }

  // required sint32 pressure = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(3, this->_internal_pressure(), target);
  }

  // required sint32 temperature = 4;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteSInt32ToArray(4, this->_internal_temperature(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:IMUSample)
  return target;
}

size_t IMUSample::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:IMUSample)
  size_t total_size = 0;

  if (_internal_has_accel()) {
    // required .Sensor accel = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *accel_);
  }

  if (_internal_has_gyro()) {
    // required .Sensor gyro = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *gyro_);
  }

  if (_internal_has_pressure()) {
    // required sint32 pressure = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
        this->_internal_pressure());
  }

  if (_internal_has_temperature()) {
    // required sint32 temperature = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
        this->_internal_temperature());
  }

  return total_size;
}
size_t IMUSample::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:IMUSample)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x0000000f) ^ 0x0000000f) == 0) {  // All required fields are present.
    // required .Sensor accel = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *accel_);

    // required .Sensor gyro = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *gyro_);

    // required sint32 pressure = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
        this->_internal_pressure());

    // required sint32 temperature = 4;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SInt32Size(
        this->_internal_temperature());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void IMUSample::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:IMUSample)
  GOOGLE_DCHECK_NE(&from, this);
  const IMUSample* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<IMUSample>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:IMUSample)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:IMUSample)
    MergeFrom(*source);
  }
}

void IMUSample::MergeFrom(const IMUSample& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:IMUSample)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _internal_mutable_accel()->::Sensor::MergeFrom(from._internal_accel());
    }
    if (cached_has_bits & 0x00000002u) {
      _internal_mutable_gyro()->::Sensor::MergeFrom(from._internal_gyro());
    }
    if (cached_has_bits & 0x00000004u) {
      pressure_ = from.pressure_;
    }
    if (cached_has_bits & 0x00000008u) {
      temperature_ = from.temperature_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void IMUSample::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:IMUSample)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void IMUSample::CopyFrom(const IMUSample& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:IMUSample)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool IMUSample::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (_internal_has_accel()) {
    if (!accel_->IsInitialized()) return false;
  }
  if (_internal_has_gyro()) {
    if (!gyro_->IsInitialized()) return false;
  }
  return true;
}

void IMUSample::InternalSwap(IMUSample* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(IMUSample, temperature_)
      + sizeof(IMUSample::temperature_)
      - PROTOBUF_FIELD_OFFSET(IMUSample, accel_)>(
          reinterpret_cast<char*>(&accel_),
          reinterpret_cast<char*>(&other->accel_));
}

::PROTOBUF_NAMESPACE_ID::Metadata IMUSample::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void LoraMsg::InitAsDefaultInstance() {
}
class LoraMsg::_Internal {
 public:
  using HasBits = decltype(std::declval<LoraMsg>()._has_bits_);
  static void set_has_buildnum(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_status(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_batt_voltage(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_configuration(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

LoraMsg::LoraMsg(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena),
  imu_(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:LoraMsg)
}
LoraMsg::LoraMsg(const LoraMsg& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_),
      imu_(from.imu_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&buildnum_, &from.buildnum_,
    static_cast<size_t>(reinterpret_cast<char*>(&configuration_) -
    reinterpret_cast<char*>(&buildnum_)) + sizeof(configuration_));
  // @@protoc_insertion_point(copy_constructor:LoraMsg)
}

void LoraMsg::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_LoraMsg_gb_5fmessages_2eproto.base);
  ::memset(&buildnum_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&configuration_) -
      reinterpret_cast<char*>(&buildnum_)) + sizeof(configuration_));
}

LoraMsg::~LoraMsg() {
  // @@protoc_insertion_point(destructor:LoraMsg)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void LoraMsg::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
}

void LoraMsg::ArenaDtor(void* object) {
  LoraMsg* _this = reinterpret_cast< LoraMsg* >(object);
  (void)_this;
}
void LoraMsg::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void LoraMsg::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const LoraMsg& LoraMsg::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_LoraMsg_gb_5fmessages_2eproto.base);
  return *internal_default_instance();
}


void LoraMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:LoraMsg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  imu_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    ::memset(&buildnum_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&configuration_) -
        reinterpret_cast<char*>(&buildnum_)) + sizeof(configuration_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* LoraMsg::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 buildnum = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_buildnum(&has_bits);
          buildnum_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 status = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_status(&has_bits);
          status_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .IMUSample imu = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_imu(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else goto handle_unusual;
        continue;
      // optional uint32 batt_voltage = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_batt_voltage(&has_bits);
          batt_voltage_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 threshold = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_threshold(&has_bits);
          threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 configuration = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          _Internal::set_has_configuration(&has_bits);
          configuration_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* LoraMsg::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:LoraMsg)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 buildnum = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_buildnum(), target);
  }

  // optional uint32 status = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->_internal_status(), target);
  }

  // repeated .IMUSample imu = 3;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->_internal_imu_size()); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, this->_internal_imu(i), target, stream);
  }

  // optional uint32 batt_voltage = 4;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->_internal_batt_voltage(), target);
  }

  // optional uint32 threshold = 5;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->_internal_threshold(), target);
  }

  // optional uint32 configuration = 6;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(6, this->_internal_configuration(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:LoraMsg)
  return target;
}

size_t LoraMsg::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:LoraMsg)
  size_t total_size = 0;

  // required uint32 buildnum = 1;
  if (_internal_has_buildnum()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_buildnum());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .IMUSample imu = 3;
  total_size += 1UL * this->_internal_imu_size();
  for (const auto& msg : this->imu_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001eu) {
    // optional uint32 status = 2;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_status());
    }

    // optional uint32 batt_voltage = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_batt_voltage());
    }

    // optional uint32 threshold = 5;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_threshold());
    }

    // optional uint32 configuration = 6;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->_internal_configuration());
    }

  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void LoraMsg::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:LoraMsg)
  GOOGLE_DCHECK_NE(&from, this);
  const LoraMsg* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<LoraMsg>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:LoraMsg)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:LoraMsg)
    MergeFrom(*source);
  }
}

void LoraMsg::MergeFrom(const LoraMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:LoraMsg)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  imu_.MergeFrom(from.imu_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      buildnum_ = from.buildnum_;
    }
    if (cached_has_bits & 0x00000002u) {
      status_ = from.status_;
    }
    if (cached_has_bits & 0x00000004u) {
      batt_voltage_ = from.batt_voltage_;
    }
    if (cached_has_bits & 0x00000008u) {
      threshold_ = from.threshold_;
    }
    if (cached_has_bits & 0x00000010u) {
      configuration_ = from.configuration_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void LoraMsg::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:LoraMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LoraMsg::CopyFrom(const LoraMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:LoraMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LoraMsg::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(imu_)) return false;
  return true;
}

void LoraMsg::InternalSwap(LoraMsg* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  imu_.InternalSwap(&other->imu_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(LoraMsg, configuration_)
      + sizeof(LoraMsg::configuration_)
      - PROTOBUF_FIELD_OFFSET(LoraMsg, buildnum_)>(
          reinterpret_cast<char*>(&buildnum_),
          reinterpret_cast<char*>(&other->buildnum_));
}

::PROTOBUF_NAMESPACE_ID::Metadata LoraMsg::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void Reprogramming::InitAsDefaultInstance() {
}
class Reprogramming::_Internal {
 public:
  using HasBits = decltype(std::declval<Reprogramming>()._has_bits_);
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_data(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_flags(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000007) ^ 0x00000007) != 0;
  }
};

Reprogramming::Reprogramming(::PROTOBUF_NAMESPACE_ID::Arena* arena)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena) {
  SharedCtor();
  RegisterArenaDtor(arena);
  // @@protoc_insertion_point(arena_constructor:Reprogramming)
}
Reprogramming::Reprogramming(const Reprogramming& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from._internal_has_data()) {
    data_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from._internal_data(),
      GetArena());
  }
  ::memcpy(&address_, &from.address_,
    static_cast<size_t>(reinterpret_cast<char*>(&flags_) -
    reinterpret_cast<char*>(&address_)) + sizeof(flags_));
  // @@protoc_insertion_point(copy_constructor:Reprogramming)
}

void Reprogramming::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_Reprogramming_gb_5fmessages_2eproto.base);
  data_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  address_ = 0u;
  flags_ = 1;
}

Reprogramming::~Reprogramming() {
  // @@protoc_insertion_point(destructor:Reprogramming)
  SharedDtor();
  _internal_metadata_.Delete<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

void Reprogramming::SharedDtor() {
  GOOGLE_DCHECK(GetArena() == nullptr);
  data_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void Reprogramming::ArenaDtor(void* object) {
  Reprogramming* _this = reinterpret_cast< Reprogramming* >(object);
  (void)_this;
}
void Reprogramming::RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena*) {
}
void Reprogramming::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const Reprogramming& Reprogramming::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_Reprogramming_gb_5fmessages_2eproto.base);
  return *internal_default_instance();
}


void Reprogramming::Clear() {
// @@protoc_insertion_point(message_clear_start:Reprogramming)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    data_.ClearNonDefaultToEmpty();
  }
  if (cached_has_bits & 0x00000006u) {
    address_ = 0u;
    flags_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* Reprogramming::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  ::PROTOBUF_NAMESPACE_ID::Arena* arena = GetArena(); (void)arena;
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 address = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_address(&has_bits);
          address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes data = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          auto str = _internal_mutable_data();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required .Reprogramming.Flags flags = 3 [default = CONTINUE];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::Reprogramming_Flags_IsValid(val))) {
            _internal_set_flags(static_cast<::Reprogramming_Flags>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag,
            _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
            ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* Reprogramming::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Reprogramming)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 address = 1;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->_internal_address(), target);
  }

  // required bytes data = 2;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_data(), target);
  }

  // required .Reprogramming.Flags flags = 3 [default = CONTINUE];
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->_internal_flags(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Reprogramming)
  return target;
}

size_t Reprogramming::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:Reprogramming)
  size_t total_size = 0;

  if (_internal_has_data()) {
    // required bytes data = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());
  }

  if (_internal_has_address()) {
    // required uint32 address = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_address());
  }

  if (_internal_has_flags()) {
    // required .Reprogramming.Flags flags = 3 [default = CONTINUE];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_flags());
  }

  return total_size;
}
size_t Reprogramming::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Reprogramming)
  size_t total_size = 0;

  if (((_has_bits_[0] & 0x00000007) ^ 0x00000007) == 0) {  // All required fields are present.
    // required bytes data = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_data());

    // required uint32 address = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->_internal_address());

    // required .Reprogramming.Flags flags = 3 [default = CONTINUE];
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->_internal_flags());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void Reprogramming::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:Reprogramming)
  GOOGLE_DCHECK_NE(&from, this);
  const Reprogramming* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<Reprogramming>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:Reprogramming)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:Reprogramming)
    MergeFrom(*source);
  }
}

void Reprogramming::MergeFrom(const Reprogramming& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Reprogramming)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      _internal_set_data(from._internal_data());
    }
    if (cached_has_bits & 0x00000002u) {
      address_ = from.address_;
    }
    if (cached_has_bits & 0x00000004u) {
      flags_ = from.flags_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void Reprogramming::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:Reprogramming)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Reprogramming::CopyFrom(const Reprogramming& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Reprogramming)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Reprogramming::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_has_bits_)) return false;
  return true;
}

void Reprogramming::InternalSwap(Reprogramming* other) {
  using std::swap;
  _internal_metadata_.Swap<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  data_.Swap(&other->data_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArena());
  swap(address_, other->address_);
  swap(flags_, other->flags_);
}

::PROTOBUF_NAMESPACE_ID::Metadata Reprogramming::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Sensor* Arena::CreateMaybeMessage< ::Sensor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Sensor >(arena);
}
template<> PROTOBUF_NOINLINE ::IMUSample* Arena::CreateMaybeMessage< ::IMUSample >(Arena* arena) {
  return Arena::CreateMessageInternal< ::IMUSample >(arena);
}
template<> PROTOBUF_NOINLINE ::LoraMsg* Arena::CreateMaybeMessage< ::LoraMsg >(Arena* arena) {
  return Arena::CreateMessageInternal< ::LoraMsg >(arena);
}
template<> PROTOBUF_NOINLINE ::Reprogramming* Arena::CreateMaybeMessage< ::Reprogramming >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Reprogramming >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
